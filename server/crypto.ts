import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';

const EC_ALGORITHM_DETAILS = {
  name: 'prime256v1', // A common and secure elliptic curve
  publicKeyEncoding: { type: 'spki', format: 'pem' } as const,
  privateKeyEncoding: { type: 'pkcs8', format: 'pem' } as const, // Keep PKCS8 for storage
};

const AES_ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 12; // 96-bit IV for AES-GCM
const AUTH_TAG_LENGTH = 16; // 128-bit authentication tag for AES-GCM

const KEYS_DIR = path.resolve(process.cwd(), 'keys');
const PRIVATE_KEY_PATH = path.join(KEYS_DIR, '.private_key.pem');
const PUBLIC_KEY_PATH = path.join(KEYS_DIR, '.public_key.pem'); 

export class ECKeyPair {
  private privateKey: crypto.KeyObject | null = null;
  public publicKey: crypto.KeyObject | null = null;
  private rawPrivateKeyBytes: Buffer | null = null; // Store raw private key bytes

  constructor() {
    // Keys are initialized to null. They will be loaded or generated by the init() method.
  }

  async init(): Promise<void> {
    await fs.mkdir(KEYS_DIR, { recursive: true });

    let privateKeyPem: string;
    let publicKeyPem: string;
    let rawPrivateKeyBuffer: Buffer;

    // --- TEMPORARY DEBUGGING: Force new key generation and direct raw byte extraction ---
    // This bypasses file loading to isolate the issue.
    console.warn('DEBUG MODE: Forcing new EC key generation and direct raw byte extraction.');
    console.warn('Please delete the "keys" folder before restarting for this to take effect.');

    const keyPairGenerated = crypto.generateKeyPairSync('ec', {
      namedCurve: EC_ALGORITHM_DETAILS.name,
      publicKeyEncoding: EC_ALGORITHM_DETAILS.publicKeyEncoding,
      privateKeyEncoding: EC_ALGORITHM_DETAILS.privateKeyEncoding,
    });

    // Use crypto.exportKey() directly on the KeyObject instances
    privateKeyPem = crypto.exportKey(EC_ALGORITHM_DETAILS.privateKeyEncoding, keyPairGenerated.privateKey).toString();
    publicKeyPem = crypto.exportKey(EC_ALGORITHM_DETAILS.publicKeyEncoding, keyPairGenerated.publicKey).toString();

    this.privateKey = keyPairGenerated.privateKey;
    this.publicKey = keyPairGenerated.publicKey;

    // This is the critical part: get raw private key bytes directly from the generated KeyObject
    // using the 'sec1' DER format, which is what ECDH.setPrivateKey expects.
    rawPrivateKeyBuffer = crypto.exportKey({ format: 'der', type: 'sec1' }, this.privateKey) as Buffer;

    // Save new PEM keys to files (still save them for future persistence)
    await fs.writeFile(PRIVATE_KEY_PATH, privateKeyPem, 'utf8');
    await fs.writeFile(PUBLIC_KEY_PATH, publicKeyPem, 'utf8');
    console.log('New EC key pair generated and saved to files (DEBUG MODE).');
    // --- END TEMPORARY DEBUGGING BLOCK ---

    this.rawPrivateKeyBytes = rawPrivateKeyBuffer; // Store the raw bytes
  }

  getPublicKeyDER(): Buffer {
    if (!this.publicKey) {
      throw new Error('Public key not initialized. Call init() first.');
    }
    const pem = crypto.exportKey({ type: 'spki', format: 'pem' }, this.publicKey) as string;
    const pemHeader = "-----BEGIN PUBLIC KEY-----";
    const pemFooter = "-----END PUBLIC KEY-----";
    const pemContents = pem.replace(pemHeader, "").replace(pemFooter, "").replace(/\s/g, "");
    return Buffer.from(pemContents, 'base64');
  }

  getPublicKeyPEM(): string {
    if (!this.publicKey) {
      throw new Error('Public key not initialized. Call init() first.');
    }
    return crypto.exportKey({ type: 'spki', format: 'pem' }, this.publicKey) as string;
  }

  async decrypt(encryptedPayload: string): Promise<string> {
    if (!this.privateKey || !this.rawPrivateKeyBytes) {
      throw new Error('Private key or raw private key bytes not initialized. Call init() first.');
    }
    try {
      // Decode the base64 string to get the JSON string
      const decodedPayload = Buffer.from(encryptedPayload, 'base64').toString('utf8');
      const { iv, encryptedData, ephemeralPublicKey } = JSON.parse(decodedPayload);

      // Convert arrays back to Buffers/Uint8Arrays
      const ivBuffer = Buffer.from(iv);
      const encryptedDataBuffer = Buffer.from(encryptedData);
      const ephemeralPublicKeyBuffer = Buffer.from(ephemeralPublicKey);

      // 1. Create ECDH instance with server's raw private key bytes
      const ecdh = crypto.createECDH(EC_ALGORITHM_DETAILS.name);
      ecdh.setPrivateKey(this.rawPrivateKeyBytes); // Use raw bytes directly

      // 2. Derive shared secret using client's ephemeral public key
      const sharedSecret = ecdh.computeSecret(ephemeralPublicKeyBuffer);

      // 3. Derive AES key from shared secret (e.g., using HKDF or a simple hash)
      const aesKey = crypto.createHash('sha256').update(sharedSecret).digest();

      // 4. Decrypt the actual data using the derived AES key and IV
      const decipher = crypto.createDecipheriv(AES_ALGORITHM, aesKey, ivBuffer);
      
      const ciphertext = encryptedDataBuffer.slice(0, encryptedDataBuffer.length - AUTH_TAG_LENGTH);
      const authTag = encryptedDataBuffer.slice(encryptedDataBuffer.length - AUTH_TAG_LENGTH);
      
      decipher.setAuthTag(authTag);

      let decrypted = decipher.update(ciphertext);
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      
      return decrypted.toString('utf8');
    } catch (error) {
      console.error('Server decryption error:', error);
      throw new Error('Failed to decrypt data on server');
    }
  }

  // Generate a hash for identicon
  getPublicKeyHash(): string {
    if (!this.publicKey) {
      throw new Error('Public key not initialized. Call init() first.');
    }
    const publicKeyDER = this.getPublicKeyDER();
    return crypto.createHash('sha256').update(publicKeyDER).digest('hex');
  }
}

// Global instance
export const serverKeyPair = new ECKeyPair();
// The init() method will be called in server/routes.ts to ensure keys are ready before routes.
